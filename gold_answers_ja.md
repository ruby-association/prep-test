**A1:** (A), (D)

[Module#define_method](https://docs.ruby-lang.org/ja/3.1/class/Module.html#I_DEFINE_METHOD)はレシーバにインスタンスメソッドを定義します。ただし、(B)では変数`name`が`Stack#push`と`Stack#pop`で共有されるため、両方とも`@contents.send(:pop, *args)`を呼びます。

[BasicObject#instance_eval](https://docs.ruby-lang.org/ja/3.1/class/BasicObject.html#I_INSTANCE_EVAL)では`def`は特異メソッドを定義しますが、[Module#class_eval](https://docs.ruby-lang.org/ja/3.1/class/Module.html#I_CLASS_EVAL)ではインスタンスメソッドを定義します。

-----------------------------------------------------------------

**A2:** (A)

- スーパークラスが明示的に指定されていないクラスは自動的に`Object`を継承します。`Object`は`Kernel`モジュールをmixinし、`BasicObject`を継承しています。

- `include`によってmixinされたモジュールは、継承チェーン上で当該クラスとそのスーパークラスの間に現れます。

- `prepend`によってmixinされたモジュールは、継承チェーン上で当該クラスより前に現れます。

`prepend`が必要なのは、クラスの定義をモジュールのmixinで上書きしたい時だけです。それ以外の場合は`include`で十分で、すでにインクルードされている他のモジュールの機能を上書きすることもできます。

-----------------------------------------------------------------

**A3:** (A)

数値リテラルの末尾の`r`は`Rational`オブジェクトを生成することを意味します。
同じ結果を他の方法(例: `1 / 3.to_r`または`Rational(1, 3)`)によって得ることもできます。

-----------------------------------------------------------------

**A4:** (A), (C)

`take`メソッドは`Enumerator::Lazy`によって定義され、列挙が何らかの方法によって強制されるまで実行が遅延されます(このメソッドの返り値は`Enumerator::Lazy`オブジェクトです)。

`Enumerator::Lazy`は`Enumerator`を継承し、`Enumerable`をインクルードしています。

`Enumerator::Lazy`によってオーバーライドされていない`Enumerable`のメソッドの呼び出しは、列挙を強制します。`first(3)`が`.force`の呼び出しを必要としないのはこのためで、操作がただちに実行され`Enumerator::Lazy`ではなく`Array`が返されます。

`Enumerator::Lazy`の`force`は`Enumerable#to_a`のただの別名であることに注意してください。

-----------------------------------------------------------------

**A5:** (D)

`...`は、キーワード引数やブロックを含め、残りの引数を転送します。

-----------------------------------------------------------------

**A6:** (A)

プライベートメソッドの呼び出し時に明示的にレシーバを指定することはできません。ただし、`self`をレシーバとして指定することはできます。

-----------------------------------------------------------------

**A7:** (B), (C)

`class << ...`構文はオブジェクトの特異クラスを定義するために使用され、特定のオブジェクトにメソッドを定義することができます。

Rubyではクラスもオブジェクトであるため、次のようにクラスにメソッドを追加することができます。

```
class << Greeter
  def hello
    # ...
  end
end
```

しかし、問題文のようにクラス定義の中で`class << self`を使用する方が一般的です。

---------------------------------------------------------------

**A8:** (A), (C)

メソッド定義で指定されているかどうかに関らず、Rubyのすべてのメソッドはブロックを受け付けます。

予約語`yield`はブロックを暗黙的に呼ぶために使用されます。
`&block`はブロックを`Proc`オブジェクトに変換するために使用され、`call()`によってブロックを呼び出したり、他のメソッドに渡したりすることができます。

-----------------------------------------------------------------

**A9:** (B), (C)

- `yield`によってブロックに引数を渡して呼ぶ場合は、`yield(x)`のように関数風に記述します。
- `Proc`オブジェプトによってブロックを呼ぶ場合は、引数を`call()`メソッドに渡します。

-----------------------------------------------------------------

**A10:** (B)

クラス変数は一つのクラス内で共有されるだけでなく、継承階層の下位にも共有されます。しがたって`A`に定義された`@@x`は、子クラスの`B`と`C`にも共有され、同じ変数が参照されます。

クラス変数はRubyのもっとも複雑な機能の一つで、このガイドでは基本的な動作についてのみ説明します。

-----------------------------------------------------------------

**A11:** (D)

`Proc`オブジェクトはブロックをカプセル化し、後で`Proc#call`によって呼び出すことを可能にします。`Proc`オブジェクトはクロージャを形成し、`Proc`オブジェクトが生成された時のローカル変数をブロックに結び付けます。

-----------------------------------------------------------------

**A12:** (A), (C)

`Proc.new`と`lambda`はいずれも`Proc`オブジェクトを生成しますが、その挙動はまったく同じというわけではありません。

- `lambda`によって生成された`Proc`は引数のチェックが厳密なのに対し、通常の`Proc`は使用されない引数を無視します。

- `lambda`内での`return`はその`lambda`自体から返りますが、通常の`Proc`内での`return`はブロックが記述されたメソッドから返ります。

-----------------------------------------------------------------

**A13:** (A)

`->(...) { }`(ラムダリテラル)構文は`lambda { |...| }`と同等の省略記法です。

-----------------------------------------------------------------

**A14:** (D)

トップレベルの`define_method`は`Object`にメソッドを定義します。

(A), (B), (C)では`Proc`を生成してローカル変数`add`に代入していますが、`add(1, 2)`は`Proc`を呼び出しません。

-----------------------------------------------------------------

**A15:** (C)

`<<~EOF`はsquiggly heredocと呼ばれ、先頭の空白が除去されます。

-----------------------------------------------------------------

**A16:** (C)

補足説明です。

- `Object#dup`はオブジェクトの特異メソッドをコピーしません。
- `Marshal.dump`は特異メソッドをもつオブジェクトをシリアライズできません。
- `Object#copy`というメソッドはありません。

-----------------------------------------------------------------

**A17:** (A)

多くのRubyのメソッド(`Kernel#puts`を含む)はオブジェクトを文字列に変換する際に`to_s`を呼び出します。`Object#to_s`のデフォルトの実装は、以下のように単純で一般的な出力を行います。

`#<ShoppingList:0x007fb651918610>`

`to_s`をオーバーライドすると、問題文のようによりよい文字列表現を提供することができます。

-----------------------------------------------------------------

**A18:** (C)

`Kernel#p`は引数に対して`inspect`を呼び出してデバッグ用途の文字列に変換します。`Object#inspect`のデフォルトの機能は基本的な情報を提供しますが、特定のクラスやオブジェクトでオーバーライドすることでカスタマイズできます。

-----------------------------------------------------------------

**A19:** (D)

`x..`は半無限区間を表現します。

[Enumerable#lazy](https://docs.ruby-lang.org/ja/3.1/class/Enumerable.html#I_LAZY)はEnumerator::Lazyを返します。Enumerator::LazyはEnumerableの多くのメソッドを再定義しており、列挙を必要になった時まで遅延させます。

-----------------------------------------------------------------

**A20: (B)**

[Enumerable#filter_map](https://docs.ruby-lang.org/ja/3.1/class/Enumerable.html#I_FILTER_MAP)はブロックが返した値のうち、真の値だけを配列として返します。

-----------------------------------------------------------------

**A21: (D)**

splat演算子(`*`)はすべての残りの右辺値を配列として一つの変数に代入します。

-----------------------------------------------------------------

**A22:** (B)

splat演算子(`*`)は、メソッドの引数で使用された場合、残りのすべての引数を配列として一つの引数で参照できるようにします。回答の*(B)*では、`fx(*args)`は0個以上の引数を取り、すべての引数を配列`args`で保持します。`fx(["apple", "banana", "carrot"])`が呼び出されると単一の引数である配列が引数のリストを表す配列の中に配置され、`args`は`[["apple","banana","carrot"]]`を参照します。

-----------------------------------------------------------------

**A23:** (A)

`_1`, `_2`, `_3`...は暗黙に定義されるブロックパラメータで、ナンバードパラメータと呼ばれます。

-----------------------------------------------------------------

**A24:** (D)

必要なキーワード引数が指定されなかった場合、`ArgumentError`が発生します。

-----------------------------------------------------------------

**A25:**  (B), (C), (D)

キーワード引数を使用する際、`**`演算子は明示的に指定されなかったキーワード引数をHashで受け取るために使用できます。

`**`演算子は、メソッド呼び出しの際にHashをキーワード引数に変換するために使用することもできます。

-----------------------------------------------------------------

**A26:** (A), (C)

Rubyではクラスはオブジェクトなので、クラスのインスタンス変数を定義することができます。

すべてのオブジェクトは、クラスも含め、特異クラスをもちます。

この例では、`Speaker`クラスとその特異クラスに`@message`というインスタンス変数が定義されています。これらは別々の変数です。

特異メソッド`Speaker.speak`は`Speaker`クラスのコンテキストで評価され、`@message`は特異クラスのインスタンス変数ではなく`Speaker`クラスのインスタンス変数を参照します。

-----------------------------------------------------------------

**A27:** (B)

この例では、`class << Speaker`は`Speaker`の特異クラス定義を再オープンし、そこでの`@message`は特異クラスに直接定義されたインスタンス変数を参照します。

-----------------------------------------------------------------

**A28:** (C)

`catch`ブロックでは、`throw`が実行されるまでコードが実行されます。`catch`に対応するシンボルが`throw`に渡されると、Rubyはブロックの実行を終了し、ブロックの次の処理から実行を継続します。

`catch`が`throw`に対応しない場合は、外側の`catch`が内側から順番に探され、トップレベルに到達すると例外が発生します。

-----------------------------------------------------------------

**A29:** (C)

2引数の`throw`が使用された場合、2番目の引数が対応する`catch`の呼び出しの値として返されます。

-----------------------------------------------------------------

**A30:** (A), (C)

問題文のクラスの継承チェーンはそれぞれ以下のとおりです。

```
ArgumentError < StandardError < Exception

ScriptError < Exception
```

`rescue`に特定の例外クラスが指定されなかった場合、デフォルトで`StandardError`とそのサブクラスが捕捉されます。ほとんどの組み込み例外クラスは`StandardError`のサブクラスですが、通常捕捉されることを想定していないいくつかの例外クラスは`Exception`を直接継承しています。

-----------------------------------------------------------------

**A31:** (C)

`rescue`に特定の例外クラスが指定されなかった場合、`StandardError`とそのサブクラスが捕捉されます。したがって、`Exception`を直接継承したクラスは捕捉されません。

一つの`begin/end`ブロックでは、複数の`rescue`節がマッチした場合も、最初にマッチした`rescue`節だけが実行されます。

-----------------------------------------------------------------

**A32:** (D)

`rescue Exception`と`rescue AnError`はいずれも発生した例外にマッチしますが、この例では`rescue Exception`が先に指定されているため実行され、残りの`rescue`節は無視されます。

-----------------------------------------------------------------

**A33:** (D)

`rescue`節で`=>`が使用された場合、発生した例外が変数に代入されます。

-----------------------------------------------------------------

**A34:** (A)

`rescue`節で`raise`が引数なしで呼び出された場合、捕捉された例外が再度`raise`されます。

例外が捕捉されていないコンテキストで`raise`が引数なしで呼び出された場合、デフォルトで`RuntimeError`が`raise`されます。

-----------------------------------------------------------------

**A35:** (C)

メソッド(または`begin/end`ブロック)の`ensure`節は、例外が発生してもしなくても、常に実行されます。ただし、`ensure`節の値は返り値としては使用されず、`ensure`節が実行される直前の評価結果が返り値として使用されます。

-----------------------------------------------------------------

**A36: (B)**

予約語`self`は現在のオブジェクトを表します。クラスメソッドでは、`self`は現在のクラスを表す`Class`インスタンスを参照します。インスタンスメソッドでは、`self`は現在のクラスの特定のインスタンスを参照します。

-----------------------------------------------------------------

**A37:** (B)

クラスメソッドでは、`self`は`Class`インスタンスを参照します。
インスタンスメソッドでは、`self`は現在インスタンス化されているオブジェクトを参照します。

-----------------------------------------------------------------

**A38:** (D)

モジュールのmixinやクラスの継承が使用された複雑な継承チェーンにおいても、`self`は常に現在のコンテキストにおけるオブジェクトを参照します。

この例では、`this_object`は`Mixin`で定義されていますが、`Indentity`クラスにインクルードされており、`self`は`Identity`の特定のオブジェクトを参照します。

-----------------------------------------------------------------

**A39:** (B)

`Class`は`Module`のサブクラスですが、クラスオブジェクトはmixinとしては使用できません(つまり、`include`、`extend`、`prepend`に`Class`オブジェクトを渡すことはできません)。

Rubyにおける`Module`と`Class`の継承関係は実装の詳細であり、機能と用途に重複はあるものの、どちらか一方がもう一方の純粋なサブタイプであるというわけではありません。

-----------------------------------------------------------------

**A40:** (A)

この例では`greet`メソッドは`Mixin`モジュール自体の特異メソッドとして定義され、他のクラスにmixinすることはできません。

(モジュールの特異メソッドと他のクラスへmixinするためのメソッドを同時に定義する方法については、`moudle_function`という機能や`extend self`という慣習についての情報を参照してください。)

-----------------------------------------------------------------

**A41:** (C)

`extend`メソッドはモジュールを一つのオブジェクトにmixinするために使用されます。クラス定義で使用された場合は、`extend`はクラス自身にmixinするため、mixinされたメソッドはクラスメソッドして使用できます。

しかし、`extend`はクラス以外のオブジェクトにも使用できます。

```
obj = Object.new
obj.extend(Mixin)
obj.greet
```

-----------------------------------------------------------------

**A42:** (B)

`include`メソッドはモジュールをクラスにmixinし、mixinされたメソッドはインスタンスメソッドとして使用できます。

-----------------------------------------------------------------

**A43:** (B)

`protected`メソッドは同じクラスかそのサブクラスのインスタンスからのみ呼び出すことができます。

-----------------------------------------------------------------

**A44:** (B)

パターンマッチは構造化された値に対して深いマッチングを行うための機能です。

パターンマッチでは、`case`式で`when`の代りに`in`を使用します。

-----------------------------------------------------------------

**A45:** (B)

`Enumerable`はmixinされるオブジェクトが要素を一つずつブロックに渡す`each`メソッドを実装していることを想定しています。`Enumerable`のさまざまなリスト操作は`each`にもとづいて実装されています。

`Enumerable`をより深く理解するため、`each`を使って他の機能がどのように実装されているか考えてみましょう。例えば、`each`がすでに定義されていれば、`select`は次のように定義できます。

```
def select(&b)
  matched = []
  
  each { |e| matched << e if b.call(e) }
  
  matched
end
```

この汎用的なパターンはmixinでは一般的です。mixinの機能は、mixinされるオブジェクトのとてもシンプルな機能にもとづいていて、mixinの機能を使用するためにはちょっとしたグルーコードを書くだけで済みます。

-----------------------------------------------------------------

**A46:** (B)

`Comparable`モジュールはこの例で使用されているすべての比較メソッド(`<`, `<=`, `==`, `>=`, `>`)を提供しています。

Each of these methods rely on the presence of a `<=>` operator which returns a negative number, zero, or a positive number depending on the sort order of two values. Ruby's core `Numeric` classes all implement this functionality, and so the following example with integers should help clarify:
これらのメソッドは、2つの要素のソート順序に応じて負の数、0、正の数のいずれかを返す`<=>`演算子に依存しています。Rubyのすべての組み込み数値クラスは、次の整数の例のように、この機能を実装しています。

```
3 <=> 8 # -1
8 <=> 8 #  0
8 <=> 3 #  1
```

これを使用して、`Comparable#<`は次のように実装することができます。

```
def <(other)
  (self <=> other) < 0
end
```

`Enumerable`同様に`Comparable`は、モジュールがいかにクラスに小さな機能だけ実装させて、mixinによってモジュールのすべての機能を提供するかを示すよい例です。

-----------------------------------------------------------------

**A47:** (C)

`<<`は現在の日付のn月前を表す`Date`オブジェクトを返します。

`>>`は現在の日付のn月後を表す`Date`オブジェクトを返します。

同じ日がその月に存在しない場合(例: 31日まである月と30までの月、うるう年とそれ以外の年などのケース)、`<<`と`>>`はその月の最後の有効な日付を返します。

```
puts(Date.new(2016,2,29) << 12) #=> 2015-02-28
puts(Date.new(2016,12,31) << 1) #=> 2016-11-30
puts(Date.new(2016,12,31) << 2) #=> 2016-10-31
```

-----------------------------------------------------------------

**A48:** (D)

[Time.strptime](https://docs.ruby-lang.org/ja/3.1/class/Time.html#C_STRPTIME)は文字列を与えられたテンプレートによって解析し、`Time`オブジェクトを返します。

[Time.parse](https://docs.ruby-lang.org/ja/3.1/class/Time.html#C_PARSE)はヒューリスティックを使用して文字列を解析し、テンプレートは受け取りません。

-----------------------------------------------------------------

**A49:** (A)

`Singleton`モジュールはSingletonパターンを実装します。

`include Singleton`はクラスの唯一のインスタンスを返す`instance`メソッドを追加します。

-----------------------------------------------------------------

**A50:** (C)

`Forwardable`モジュールは、[Forwardable.def_delegator](https://docs.ruby-lang.org/ja/3.1/class/Forwardable.html#I_DEF_DELEGATOR)を使用して、指定されたメソッドを特定のオブジェクトに委譲します。

-----------------------------------------------------------------

